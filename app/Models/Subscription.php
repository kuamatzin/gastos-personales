<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Carbon\Carbon;

class Subscription extends Model
{
    use HasFactory;

    protected $fillable = [
        'user_id',
        'name',
        'description',
        'amount',
        'currency',
        'periodicity',
        'next_charge_date',
        'last_charge_date',
        'status',
        'category_id',
        'merchant_name',
        'notification_days',
    ];

    protected $casts = [
        'amount' => 'decimal:2',
        'next_charge_date' => 'date',
        'last_charge_date' => 'date',
    ];

    /**
     * Get the user that owns the subscription
     */
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the category of the subscription
     */
    public function category()
    {
        return $this->belongsTo(Category::class);
    }

    /**
     * Get the expenses generated by this subscription
     */
    public function subscriptionExpenses()
    {
        return $this->hasMany(SubscriptionExpense::class);
    }

    /**
     * Get the actual expenses linked through subscription_expenses
     */
    public function expenses()
    {
        return $this->belongsToMany(Expense::class, 'subscription_expenses')
            ->withPivot('charge_date', 'status')
            ->withTimestamps();
    }

    /**
     * Check if subscription is due for charge
     */
    public function isDue(): bool
    {
        if ($this->status !== 'active') {
            return false;
        }

        return $this->next_charge_date->isToday() || $this->next_charge_date->isPast();
    }

    /**
     * Check if notification should be sent
     */
    public function shouldNotify(): bool
    {
        if ($this->status !== 'active') {
            return false;
        }

        $notificationDate = $this->next_charge_date->copy()->subDays($this->notification_days);
        return $notificationDate->isToday();
    }

    /**
     * Calculate the next charge date based on periodicity
     */
    public function calculateNextChargeDate(?Carbon $fromDate = null): Carbon
    {
        $date = $fromDate ?: ($this->next_charge_date ?: Carbon::now());

        return match ($this->periodicity) {
            'daily' => $date->copy()->addDay(),
            'weekly' => $date->copy()->addWeek(),
            'biweekly' => $date->copy()->addWeeks(2),
            'monthly' => $date->copy()->addMonth(),
            'quarterly' => $date->copy()->addMonths(3),
            'yearly' => $date->copy()->addYear(),
            default => $date,
        };
    }

    /**
     * Create an expense for this subscription
     */
    public function createExpense(): ?Expense
    {
        if (!$this->isDue()) {
            return null;
        }

        $expense = Expense::create([
            'user_id' => $this->user_id,
            'amount' => $this->amount,
            'currency' => $this->currency,
            'description' => $this->description ?: $this->name,
            'category_id' => $this->category_id,
            'merchant_name' => $this->merchant_name,
            'date' => $this->next_charge_date->format('Y-m-d'),
            'is_confirmed' => true,
            'inference_method' => 'subscription',
            'category_confidence' => 1.0,
        ]);

        // Create the link in subscription_expenses
        SubscriptionExpense::create([
            'subscription_id' => $this->id,
            'expense_id' => $expense->id,
            'charge_date' => $this->next_charge_date,
            'status' => 'processed',
        ]);

        // Update subscription dates
        $this->update([
            'last_charge_date' => $this->next_charge_date,
            'next_charge_date' => $this->calculateNextChargeDate(),
        ]);

        return $expense;
    }

    /**
     * Get human-readable periodicity
     */
    public function getPeriodicityText(string $language = 'es'): string
    {
        $translations = [
            'es' => [
                'daily' => 'Diaria',
                'weekly' => 'Semanal',
                'biweekly' => 'Quincenal',
                'monthly' => 'Mensual',
                'quarterly' => 'Trimestral',
                'yearly' => 'Anual',
            ],
            'en' => [
                'daily' => 'Daily',
                'weekly' => 'Weekly',
                'biweekly' => 'Biweekly',
                'monthly' => 'Monthly',
                'quarterly' => 'Quarterly',
                'yearly' => 'Yearly',
            ],
        ];

        return $translations[$language][$this->periodicity] ?? $this->periodicity;
    }

    /**
     * Pause the subscription
     */
    public function pause(): void
    {
        $this->update(['status' => 'paused']);
    }

    /**
     * Resume the subscription
     */
    public function resume(): void
    {
        if ($this->status === 'paused') {
            // If the next charge date is in the past, update it to the next cycle
            if ($this->next_charge_date->isPast()) {
                $this->next_charge_date = $this->calculateNextChargeDate(Carbon::now());
            }
            
            $this->update(['status' => 'active']);
        }
    }

    /**
     * Cancel the subscription
     */
    public function cancel(): void
    {
        $this->update(['status' => 'cancelled']);
    }
}